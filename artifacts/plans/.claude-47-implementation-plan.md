# Implementation Plan: Surface Authentication Errors in Claude Sandbox

## Branch
`fix/.claude-47-auth-errors`

## Overview
The jq filter in entrypoint.sh (line 257) only passes through `text_delta` events, silently dropping authentication and other error events from the Claude CLI. We need to modify the output pipeline to handle both text streaming (for normal operation) and error events (for failures), ensuring errors go to stderr and are visible to users and Telegram notifications.

## Solution Architecture

**Chosen Approach: Single expanded jq filter with dual output streams**

We'll modify the jq filter to:
1. Detect and route `text_delta` events to stdout (preserves streaming)
2. Detect and route error events to stderr (makes them visible)
3. Handle unknown/unexpected event types gracefully (don't crash)

**Why this approach:**
- Single jq process (no complex process substitution)
- Preserves streaming semantics (errors appear immediately)
- Clear separation (stdout = Claude output, stderr = errors)
- Works with existing cleanup trap and Telegram notification
- Minimal performance impact (jq runs once per event)

**Trade-offs:**
- Requires knowing error event structure (we'll need to test/discover it)
- jq filter becomes slightly more complex (but still maintainable)
- Alternative approaches considered:
  - `tee` with dual filters: More complex, harder to maintain
  - Per-line bash loop: Too slow for streaming
  - Capture-on-exit: Loses real-time visibility

## Investigation Required (Step 0)

**CRITICAL: Before implementing, we must capture actual error event format.**

The spec notes this is unknown. The implementer should:

1. **Test invalid API key format:**
```bash
cd /workspace/claude-sandbox
docker compose build
docker compose run --rm \
  -e TASK="test" \
  -e GITHUB_TOKEN="$GITHUB_TOKEN" \
  -e ANTHROPIC_API_KEY="invalid_key_test_12345" \
  -e REPO_URL="https://github.com/landovsky/beads.git" \
  claude bash -c 'git config --global --add safe.directory /workspace && claude -p "test" --output-format stream-json --verbose 2>&1 | head -50'
```

2. **Document the JSON structure** - Look for events with:
   - `.type == "error"` or `.type == "message_stop"` or similar
   - Fields like `.error`, `.message`, `.code`
   
3. **Test with expired OAuth token** (if available)

4. **Test with network error** (disconnect, invalid endpoint)

Expected event structure (hypothesis, needs confirmation):
```json
{"type": "error", "error": {"type": "authentication_error", "message": "Invalid API key"}}
```

OR possibly:
```json
{"type": "message_stop", "message": {"stop_reason": "error", "error": {...}}}
```

**If investigation is blocked** (cannot get invalid token easily), proceed with defensive implementation that handles multiple possible formats.

## Files to Change

### 1. `/workspace/claude-sandbox/entrypoint.sh` (lines 251-257)

**Current code:**
```bash
# Execute Claude with full permissions and live streaming output
# bash
exec claude --dangerously-skip-permissions -p "$TASK" \
  --output-format stream-json \
  --verbose \
  --include-partial-messages | \
  jq -rj 'select(.type == "stream_event" and .event.delta.type? == "text_delta") | .event.delta.text'
```

**New code** (adjust based on investigation results):
```bash
# Execute Claude with full permissions and live streaming output
# Stream text to stdout, errors to stderr
exec claude --dangerously-skip-permissions -p "$TASK" \
  --output-format stream-json \
  --verbose \
  --include-partial-messages | \
  jq -rj '
    if .type == "stream_event" and .event.delta.type? == "text_delta" then
      # Normal text output to stdout
      .event.delta.text
    elif .type == "error" then
      # Error events to stderr (adjust .error.message path based on investigation)
      ("\u001b[31m[claude error]\u001b[0m " + (.error.message // .message // "Unknown error") + "\n") | stderr
    elif .type == "message_stop" and .message.stop_reason? == "error" then
      # Alternative error format (adjust based on investigation)
      ("\u001b[31m[claude error]\u001b[0m " + (.message.error.message // "Unknown error") + "\n") | stderr
    else
      # Ignore other event types silently
      empty
    end
  '
```

**Notes on the jq filter:**
- `\u001b[31m` = red color for errors (matches existing error() function pattern)
- `\u001b[0m` = reset color
- `stderr` is a jq function that writes to file descriptor 2
- `// "Unknown error"` = fallback if message field is missing
- `empty` = discard event without output (like original select)
- `-rj` flags: `-r` = raw output (no JSON encoding), `-j` = no newlines (for text streaming)

**Why color-code errors:**
- Matches existing entrypoint.sh error reporting pattern (line 19)
- Makes errors visually distinct in logs
- Grep-able with `[claude error]` prefix

### 2. `/workspace/claude-sandbox/entrypoint.sh` (lines 24-36) - Enhancement

**Current cleanup function:**
```bash
cleanup() {
  EXIT_CODE=$?
  echo ""
  separator
  if [ $EXIT_CODE -eq 0 ]; then
    success "Session completed successfully"
  else
    error "Session ended with exit code: $EXIT_CODE"
  fi
  /usr/local/bin/notify-telegram.sh "$EXIT_CODE"
}
```

**No changes needed here** - errors will already be visible on stderr before cleanup runs.

**Alternative considered**: Capture last error message from stderr to pass to Telegram. Rejected because:
- Adds complexity (temp file, parsing)
- Errors are timestamped, last != root cause
- Exit code is sufficient for notifications (user can check logs for details)

### 3. `/workspace/claude-sandbox/notify-telegram.sh` - No changes

**Current behavior is correct:**
- Line 32: Shows exit code in status message
- Exit code will be non-zero on auth failure
- User sees "Failed (exit code: N)" in Telegram
- User can check container logs to see the actual error (now visible on stderr)

**Why no changes:**
- Telegram notification already includes context (task, repo, branch)
- Error details in logs are more reliable than trying to extract from stderr
- Keeps notification simple and focused

## Implementation Sequence

### Step 1: Investigation (required first)
1. Test with invalid API key as shown above
2. Test with expired OAuth token if available  
3. Document actual error event JSON structure in a comment or temp file
4. Adjust jq filter in Step 2 based on findings

### Step 2: Modify jq filter
1. Create feature branch: `git checkout -b fix/.claude-47-auth-errors`
2. Edit `entrypoint.sh` line 251-257
3. Replace simple filter with expanded filter (based on Step 1 findings)
4. Ensure color codes work (`\u001b[31m` in jq)
5. Ensure stderr routing works (` | stderr` in jq)

### Step 3: Local testing
1. **Test normal operation** (valid token):
   ```bash
   bin/claude-sandbox build
   bin/claude-sandbox local "what is 2+2"
   ```
   Expected: Text streams normally, no errors, exit code 0

2. **Test invalid API key**:
   ```bash
   ANTHROPIC_API_KEY="invalid_test_key" bin/claude-sandbox local "test"
   ```
   Expected: 
   - Red error message visible on terminal
   - Exit code non-zero
   - Cleanup shows "Session ended with exit code: N"

3. **Test with valid OAuth token** (ensure we didn't break anything):
   ```bash
   CLAUDE_CODE_OAUTH_TOKEN="$CLAUDE_CODE_OAUTH_TOKEN" bin/claude-sandbox local "what is the weather"
   ```
   Expected: Normal text streaming

4. **Test Telegram notification** (if configured):
   - Check that failed run sends notification with exit code

### Step 4: Edge case testing
1. **Malformed JSON** - Pipe invalid JSON to jq:
   ```bash
   echo '{"invalid json' | jq -rj '<new filter>'
   ```
   Expected: jq should fail gracefully, not hang

2. **Multiple errors** - If possible, trigger scenario with multiple error events
   Expected: All errors should be visible on stderr

3. **Mixed output** - If there's a scenario where errors appear mid-stream
   Expected: Errors on stderr, text on stdout, both visible

### Step 5: Documentation updates
Per spec requirement (line 159), update:

1. **`artifacts/lessons-learned.md`** - Add entry:
   ```markdown
   ## [DATE] - .claude-47 - Authentication error handling
   
   ### What worked well
   - Single jq filter with dual output streams (stdout/stderr) is clean and performant
   - Error event structure: [document actual format found]
   - Color-coded error prefix makes errors visible in logs
   
   ### What to avoid
   - Don't assume error event structure matches text_delta structure
   - Testing with invalid credentials is required to see actual error format
   
   ### Pattern for future
   - When using `--output-format stream-json`, always handle multiple event types
   - Route errors to stderr for visibility
   - Use jq's `stderr` function for error output
   ```

## Watch Out For

### Risk 1: Unknown error event structure
**Why risky**: Claude CLI error format is undocumented. Our filter might not catch all error types.

**How to mitigate**:
- Test with multiple failure scenarios (invalid key, expired token, network error)
- Use defensive `.field // .otherfield // "fallback"` chains in jq
- Add catch-all `else` clause to log unexpected event types during testing

### Risk 2: jq stderr function compatibility
**Why risky**: The `stderr` function in jq might not work as expected in all versions.

**How to mitigate**:
- Test early in Step 2
- Alternative: Use `@sh | "echo \(.) >&2"` but this loses streaming
- Check jq version in container (`jq --version`) - should be 1.6+

### Risk 3: Color codes in jq strings
**Why risky**: ANSI escape sequences in jq strings might not render correctly.

**How to mitigate**:
- Test in Step 2 with a simple example
- Alternative: Remove colors, just use `[claude error]` prefix
- Verify terminal supports colors (most do)

### Risk 4: Breaking text streaming
**Why risky**: Any mistake in jq filter could break normal Claude output.

**How to mitigate**:
- Test Step 3.1 and 3.3 thoroughly before considering edge cases
- Keep original filter commented out in code for quick rollback
- Test with long-running task to ensure streaming isn't buffered

### Risk 5: Exit code not propagating
**Why risky**: Using `exec` should preserve exit code, but jq in pipeline might interfere.

**How to mitigate**:
- Verify in testing that `$?` in cleanup() is non-zero on auth failure
- If broken, may need to use `set -o pipefail` before exec
- Test both success and failure scenarios

## Dependencies to be Careful With

### 1. `/workspace/claude-sandbox/entrypoint.sh` (lines 24-36)
**What depends on this**: cleanup() trap is called on ANY exit (success, failure, interrupt)
- The trap will still work with our changes (errors go to stderr before cleanup)
- Exit code propagation is critical - test thoroughly

### 2. `/workspace/claude-sandbox/notify-telegram.sh`
**What depends on this**: Receives exit code from cleanup()
- No changes needed, but verify exit code is correct after our changes
- Non-zero exit code triggers "Failed" status

### 3. `docker-compose.yml` (not changing, but aware)
**What this provides**: The container environment where jq runs
- jq version must support `stderr` function (check Dockerfile)
- Color output works because docker compose preserves TTY by default

### 4. Claude CLI itself (external dependency)
**What we depend on**: `--output-format stream-json` producing consistent event types
- We can't control this, but we can handle unknown events gracefully
- Document the version tested against in lessons-learned

## Testing Strategy

### Unit-level (jq filter testing)
```bash
# Test text_delta handling
echo '{"type":"stream_event","event":{"delta":{"type":"text_delta","text":"hello"}}}' | jq -rj '<new filter>'
# Expected: hello (no newline)

# Test error handling (adjust JSON based on investigation)
echo '{"type":"error","error":{"message":"Auth failed"}}' | jq -rj '<new filter>' 2>&1
# Expected: [claude error] Auth failed (to stderr, with red color)

# Test unknown event type
echo '{"type":"unknown","data":"something"}' | jq -rj '<new filter>'
# Expected: (empty output, no error)
```

### Integration (container level)
- Step 3 covers this
- Test with real Claude CLI, real auth failures, real tasks

### User acceptance
From spec (lines 92-99):
- [x] Invalid API key shows error message to user ← Test in Step 3.2
- [x] Expired OAuth token shows error message ← Test if token available
- [x] Normal operation still streams text ← Test in Step 3.1, 3.3
- [x] Exit code is non-zero on auth failure ← Verify in all failure tests
- [x] Error output goes to stderr ← Verify with `2>&1` redirection tests
- [x] Telegram notification includes exit code ← Test in Step 3.4

### Edge cases from spec (lines 85-90)
- [x] Multiple error events ← Test in Step 4.2
- [x] Error + recovery (if Claude supports this) ← Test in Step 4.3
- [x] Non-auth errors (rate limit, network) ← Test if scenarios available
- [x] Malformed JSON ← Test in Step 4.1

## Rollback Plan

### If jq filter breaks text streaming
1. Revert entrypoint.sh lines 251-257 to original:
   ```bash
   git checkout main -- claude-sandbox/entrypoint.sh
   ```
2. Rebuild image: `bin/claude-sandbox build`
3. Test: `bin/claude-sandbox local "test"`

### If error detection doesn't work
- Original behavior: Silent failure with exit code
- No worse than before, just incomplete fix
- Can iterate on jq filter without breaking existing functionality

### If performance degrades
- jq should not add noticeable latency (single pass)
- If it does, fall back to simpler filter and investigate separately

## Success Criteria

Before marking task complete:

1. ✅ Invalid API key shows error message on terminal
2. ✅ Error message is color-coded (red) and prefixed with `[claude error]`
3. ✅ Error appears on stderr (can redirect separately from stdout)
4. ✅ Normal text streaming still works (tested with valid token)
5. ✅ Exit code is non-zero on authentication failure
6. ✅ Telegram notification shows "Failed (exit code: N)" on auth failure
7. ✅ No regression: Valid token tasks work as before
8. ✅ Documentation updated: lessons-learned.md has entry
9. ✅ Code is tested with at least 3 scenarios: success, invalid key, (expired token if available)

## Lessons from Past Work

From `artifacts/lessons-learned.md`:
- **Toolset verification**: Not applicable here (shell script, not agent code)
- **Process improvements**: This plan explicitly documents why we chose jq approach over alternatives (spec suggested multiple options, we picked one with rationale)

From `artifacts/workflow-design/WORKFLOW.md`:
- **Documentation is distributed**: Implementer updates lessons-learned.md as part of this task (listed in Step 5)

## Open Questions for Implementer

1. **Error event format**: Step 1 investigation will answer this
2. **jq stderr compatibility**: Test early in Step 2
3. **Color output**: Test early, can remove if problematic
4. **Multiple error types**: Discovery during testing will inform handling

## Notes for Reviewer

When reviewing this implementation:
- **Critical check**: Normal text streaming must still work (test with valid token)
- **Critical check**: Error messages must be visible (test with invalid token)
- **Major check**: Exit code propagation (cleanup function gets non-zero)
- **Minor check**: Colors render correctly (aesthetic, not functional)
- **Lessons capture**: Ensure implementer documented actual error event structure found
